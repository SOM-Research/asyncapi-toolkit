/*
 * generated by Xtext 2.17.0
 */
package io.github.abelgomez.asyncapi.serializer;

import com.google.inject.Inject;
import io.github.abelgomez.asyncapi.asyncApi.AsyncAPI;
import io.github.abelgomez.asyncapi.asyncApi.AsyncApiPackage;
import io.github.abelgomez.asyncapi.asyncApi.Components;
import io.github.abelgomez.asyncapi.asyncApi.Contact;
import io.github.abelgomez.asyncapi.asyncApi.Info;
import io.github.abelgomez.asyncapi.asyncApi.License;
import io.github.abelgomez.asyncapi.asyncApi.Message;
import io.github.abelgomez.asyncapi.asyncApi.NamedMessage;
import io.github.abelgomez.asyncapi.asyncApi.NamedSchema;
import io.github.abelgomez.asyncapi.asyncApi.Reference;
import io.github.abelgomez.asyncapi.asyncApi.Schema;
import io.github.abelgomez.asyncapi.asyncApi.Server;
import io.github.abelgomez.asyncapi.asyncApi.Topic;
import io.github.abelgomez.asyncapi.asyncApi.Variable;
import io.github.abelgomez.asyncapi.services.AsyncApiGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AsyncApiSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AsyncApiGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AsyncApiPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AsyncApiPackage.ASYNC_API:
				sequence_AsyncAPI(context, (AsyncAPI) semanticObject); 
				return; 
			case AsyncApiPackage.COMPONENTS:
				sequence_Components(context, (Components) semanticObject); 
				return; 
			case AsyncApiPackage.CONTACT:
				sequence_Contact(context, (Contact) semanticObject); 
				return; 
			case AsyncApiPackage.INFO:
				sequence_Info(context, (Info) semanticObject); 
				return; 
			case AsyncApiPackage.LICENSE:
				sequence_License(context, (License) semanticObject); 
				return; 
			case AsyncApiPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_MESSAGE:
				sequence_NamedMessage(context, (NamedMessage) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_SCHEMA:
				sequence_NamedSchema(context, (NamedSchema) semanticObject); 
				return; 
			case AsyncApiPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case AsyncApiPackage.SCHEMA:
				sequence_Schema(context, (Schema) semanticObject); 
				return; 
			case AsyncApiPackage.SERVER:
				sequence_Server(context, (Server) semanticObject); 
				return; 
			case AsyncApiPackage.TOPIC:
				sequence_Topic(context, (Topic) semanticObject); 
				return; 
			case AsyncApiPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AsyncAPI returns AsyncAPI
	 *
	 * Constraint:
	 *     ((version=VersionNumber | info=Info | components=Components)? (servers+=Server servers+=Server*)? (topics+=Topic topics+=Topic*)?)+
	 */
	protected void sequence_AsyncAPI(ISerializationContext context, AsyncAPI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Components
	 *
	 * Constraint:
	 *     ((schemas+=NamedSchema schemas+=NamedSchema*) | (messages+=NamedMessage messages+=NamedMessage*))*
	 */
	protected void sequence_Components(ISerializationContext context, Components semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contact returns Contact
	 *
	 * Constraint:
	 *     (name=STRING | url=STRING | email=STRING)*
	 */
	protected void sequence_Contact(ISerializationContext context, Contact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Info returns Info
	 *
	 * Constraint:
	 *     (
	 *         title=STRING | 
	 *         version=STRING | 
	 *         description=STRING | 
	 *         termsOfService=STRING | 
	 *         contact=Contact | 
	 *         license=License
	 *     )*
	 */
	protected void sequence_Info(ISerializationContext context, Info semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     License returns License
	 *
	 * Constraint:
	 *     (name=STRING | url=STRING)*
	 */
	protected void sequence_License(ISerializationContext context, License semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractMessage returns Message
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (summary=STRING | description=STRING | headers=AbstractSchema | payload=AbstractSchema)*
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedMessage returns NamedMessage
	 *
	 * Constraint:
	 *     (name=STRING message=AbstractMessage)
	 */
	protected void sequence_NamedMessage(ISerializationContext context, NamedMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedMessageAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedMessageAccess().getMessageAbstractMessageParserRuleCall_3_0(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedSchema returns NamedSchema
	 *
	 * Constraint:
	 *     (name=STRING schema=AbstractSchema)
	 */
	protected void sequence_NamedSchema(ISerializationContext context, NamedSchema semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__SCHEMA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__SCHEMA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedSchemaAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedSchemaAccess().getSchemaAbstractSchemaParserRuleCall_3_0(), semanticObject.getSchema());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractMessage returns Reference
	 *     AbstractSchema returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     (refname=STRING? uri=STRING)
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractSchema returns Schema
	 *     Schema returns Schema
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             title=STRING | 
	 *             type=STRING | 
	 *             description=STRING | 
	 *             format=STRING | 
	 *             default=STRING | 
	 *             payload=AbstractSchema
	 *         )? 
	 *         (properties+=NamedSchema properties+=NamedSchema*)? 
	 *         (enum+=STRING enum+=STRING*)?
	 *     )+
	 */
	protected void sequence_Schema(ISerializationContext context, Schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Server returns Server
	 *
	 * Constraint:
	 *     ((title=STRING | scheme=Scheme | description=STRING)? (variables+=Variable variables+=Variable*)?)+
	 */
	protected void sequence_Server(ISerializationContext context, Server semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Topic returns Topic
	 *
	 * Constraint:
	 *     (name=STRING (publish=AbstractMessage | subscribe=AbstractMessage)*)
	 */
	protected void sequence_Topic(ISerializationContext context, Topic semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=STRING ((description=STRING | default=STRING)? (enum+=STRING enum+=STRING*)?)+)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
