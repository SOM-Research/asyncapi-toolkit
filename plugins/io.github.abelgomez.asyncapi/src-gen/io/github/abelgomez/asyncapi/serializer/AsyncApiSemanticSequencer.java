/*
 * generated by Xtext 2.17.0
 */
package io.github.abelgomez.asyncapi.serializer;

import com.google.inject.Inject;
import io.github.abelgomez.asyncapi.asyncApi.AsyncAPI;
import io.github.abelgomez.asyncapi.asyncApi.AsyncApiPackage;
import io.github.abelgomez.asyncapi.asyncApi.Channel;
import io.github.abelgomez.asyncapi.asyncApi.Components;
import io.github.abelgomez.asyncapi.asyncApi.Contact;
import io.github.abelgomez.asyncapi.asyncApi.Info;
import io.github.abelgomez.asyncapi.asyncApi.License;
import io.github.abelgomez.asyncapi.asyncApi.Message;
import io.github.abelgomez.asyncapi.asyncApi.MessageTrait;
import io.github.abelgomez.asyncapi.asyncApi.NamedMessage;
import io.github.abelgomez.asyncapi.asyncApi.NamedMessageTrait;
import io.github.abelgomez.asyncapi.asyncApi.NamedOperationTrait;
import io.github.abelgomez.asyncapi.asyncApi.NamedParameter;
import io.github.abelgomez.asyncapi.asyncApi.NamedSchema;
import io.github.abelgomez.asyncapi.asyncApi.Operation;
import io.github.abelgomez.asyncapi.asyncApi.OperationTrait;
import io.github.abelgomez.asyncapi.asyncApi.Reference;
import io.github.abelgomez.asyncapi.asyncApi.Schema;
import io.github.abelgomez.asyncapi.asyncApi.Server;
import io.github.abelgomez.asyncapi.asyncApi.Tag;
import io.github.abelgomez.asyncapi.asyncApi.Variable;
import io.github.abelgomez.asyncapi.services.AsyncApiGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class AsyncApiSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private AsyncApiGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == AsyncApiPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case AsyncApiPackage.ASYNC_API:
				sequence_AsyncAPI(context, (AsyncAPI) semanticObject); 
				return; 
			case AsyncApiPackage.CHANNEL:
				sequence_Channel(context, (Channel) semanticObject); 
				return; 
			case AsyncApiPackage.COMPONENTS:
				sequence_Components(context, (Components) semanticObject); 
				return; 
			case AsyncApiPackage.CONTACT:
				sequence_Contact(context, (Contact) semanticObject); 
				return; 
			case AsyncApiPackage.INFO:
				sequence_Info(context, (Info) semanticObject); 
				return; 
			case AsyncApiPackage.LICENSE:
				sequence_License(context, (License) semanticObject); 
				return; 
			case AsyncApiPackage.MESSAGE:
				sequence_Message(context, (Message) semanticObject); 
				return; 
			case AsyncApiPackage.MESSAGE_TRAIT:
				sequence_MessageTrait(context, (MessageTrait) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_MESSAGE:
				sequence_NamedMessage(context, (NamedMessage) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_MESSAGE_TRAIT:
				sequence_NamedMessageTrait(context, (NamedMessageTrait) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_OPERATION_TRAIT:
				sequence_NamedOperationTrait(context, (NamedOperationTrait) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_PARAMETER:
				sequence_NamedParameter(context, (NamedParameter) semanticObject); 
				return; 
			case AsyncApiPackage.NAMED_SCHEMA:
				sequence_NamedSchema(context, (NamedSchema) semanticObject); 
				return; 
			case AsyncApiPackage.OPERATION:
				sequence_Operation(context, (Operation) semanticObject); 
				return; 
			case AsyncApiPackage.OPERATION_TRAIT:
				sequence_OperationTrait(context, (OperationTrait) semanticObject); 
				return; 
			case AsyncApiPackage.PARAMETER:
				sequence_Parameter(context, (io.github.abelgomez.asyncapi.asyncApi.Parameter) semanticObject); 
				return; 
			case AsyncApiPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case AsyncApiPackage.SCHEMA:
				sequence_Schema(context, (Schema) semanticObject); 
				return; 
			case AsyncApiPackage.SERVER:
				sequence_Server(context, (Server) semanticObject); 
				return; 
			case AsyncApiPackage.TAG:
				sequence_Tag(context, (Tag) semanticObject); 
				return; 
			case AsyncApiPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AsyncAPI returns AsyncAPI
	 *
	 * Constraint:
	 *     ((version=VersionNumber | info=Info | components=Components)? (servers+=Server servers+=Server*)? (channels+=Channel channels+=Channel*)?)+
	 */
	protected void sequence_AsyncAPI(ISerializationContext context, AsyncAPI semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Channel returns Channel
	 *
	 * Constraint:
	 *     (
	 *         name=AnyString 
	 *         (
	 *             (description=AnyString | publish=Operation | subscribe=Operation | title=AnyString)? 
	 *             (parameters+=NamedParameter parameters+=NamedParameter*)?
	 *         )+
	 *     )
	 */
	protected void sequence_Channel(ISerializationContext context, Channel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Components returns Components
	 *
	 * Constraint:
	 *     (
	 *         (schemas+=NamedSchema schemas+=NamedSchema*) | 
	 *         (messages+=NamedMessage messages+=NamedMessage*) | 
	 *         (parameters+=NamedParameter parameters+=NamedParameter*) | 
	 *         (operationTraits+=NamedOperationTrait operationTraits+=NamedOperationTrait*) | 
	 *         (messageTraits+=NamedMessageTrait messageTraits+=NamedMessageTrait*)
	 *     )*
	 */
	protected void sequence_Components(ISerializationContext context, Components semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contact returns Contact
	 *
	 * Constraint:
	 *     (name=AnyString | url=AnyString | email=AnyString)*
	 */
	protected void sequence_Contact(ISerializationContext context, Contact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Info returns Info
	 *
	 * Constraint:
	 *     (
	 *         title=AnyString | 
	 *         version=AnyString | 
	 *         description=AnyString | 
	 *         termsOfService=AnyString | 
	 *         contact=Contact | 
	 *         license=License
	 *     )*
	 */
	protected void sequence_Info(ISerializationContext context, Info semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     License returns License
	 *
	 * Constraint:
	 *     (name=AnyString | url=AnyString)*
	 */
	protected void sequence_License(ISerializationContext context, License semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractMessageTrait returns MessageTrait
	 *     MessageTrait returns MessageTrait
	 *
	 * Constraint:
	 *     ((summary=AnyString | description=AnyString | deprecated=Boolean | headers=AbstractSchema)? (tags+=Tag tags+=Tag*)?)+
	 */
	protected void sequence_MessageTrait(ISerializationContext context, MessageTrait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractMessage returns Message
	 *     Message returns Message
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             name=AnyString | 
	 *             title=AnyString | 
	 *             summary=AnyString | 
	 *             description=AnyString | 
	 *             deprecated=Boolean | 
	 *             headers=AbstractSchema | 
	 *             payload=AbstractSchema
	 *         )? 
	 *         (traits+=AbstractMessageTrait traits+=AbstractMessageTrait*)? 
	 *         (tags+=Tag tags+=Tag*)?
	 *     )+
	 */
	protected void sequence_Message(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NamedMessageTrait returns NamedMessageTrait
	 *
	 * Constraint:
	 *     (name=AnyString messageTrait=AbstractMessageTrait)
	 */
	protected void sequence_NamedMessageTrait(ISerializationContext context, NamedMessageTrait semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE_TRAIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE_TRAIT__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE_TRAIT__MESSAGE_TRAIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE_TRAIT__MESSAGE_TRAIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedMessageTraitAccess().getNameAnyStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedMessageTraitAccess().getMessageTraitAbstractMessageTraitParserRuleCall_3_0(), semanticObject.getMessageTrait());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedMessage returns NamedMessage
	 *
	 * Constraint:
	 *     (name=AnyString message=AbstractMessage)
	 */
	protected void sequence_NamedMessage(ISerializationContext context, NamedMessage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_MESSAGE__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedMessageAccess().getNameAnyStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedMessageAccess().getMessageAbstractMessageParserRuleCall_3_0(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedOperationTrait returns NamedOperationTrait
	 *
	 * Constraint:
	 *     (name=AnyString operationTrait=AbstractOperationTrait)
	 */
	protected void sequence_NamedOperationTrait(ISerializationContext context, NamedOperationTrait semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_OPERATION_TRAIT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_OPERATION_TRAIT__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_OPERATION_TRAIT__OPERATION_TRAIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_OPERATION_TRAIT__OPERATION_TRAIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedOperationTraitAccess().getNameAnyStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedOperationTraitAccess().getOperationTraitAbstractOperationTraitParserRuleCall_3_0(), semanticObject.getOperationTrait());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedParameter returns NamedParameter
	 *
	 * Constraint:
	 *     (name=AnyString parameter=AbstractParameter)
	 */
	protected void sequence_NamedParameter(ISerializationContext context, NamedParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_PARAMETER__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_PARAMETER__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_PARAMETER__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedParameterAccess().getNameAnyStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedParameterAccess().getParameterAbstractParameterParserRuleCall_3_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NamedSchema returns NamedSchema
	 *
	 * Constraint:
	 *     (name=AnyString schema=AbstractSchema)
	 */
	protected void sequence_NamedSchema(ISerializationContext context, NamedSchema semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__NAME));
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__SCHEMA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.NAMED_SCHEMA__SCHEMA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamedSchemaAccess().getNameAnyStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getNamedSchemaAccess().getSchemaAbstractSchemaParserRuleCall_3_0(), semanticObject.getSchema());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractOperationTrait returns OperationTrait
	 *     OperationTrait returns OperationTrait
	 *
	 * Constraint:
	 *     (operationId=AnyString | summary=AnyString | description=AnyString)*
	 */
	protected void sequence_OperationTrait(ISerializationContext context, OperationTrait semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Operation returns Operation
	 *
	 * Constraint:
	 *     (
	 *         (operationId=AnyString | summary=AnyString | description=AnyString | message=AbstractMessage)? 
	 *         (traits+=AbstractOperationTrait traits+=AbstractOperationTrait*)?
	 *     )+
	 */
	protected void sequence_Operation(ISerializationContext context, Operation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractParameter returns Parameter
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (description=AnyString | schema=AbstractSchema | location=AnyString)*
	 */
	protected void sequence_Parameter(ISerializationContext context, io.github.abelgomez.asyncapi.asyncApi.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractMessage returns Reference
	 *     AbstractSchema returns Reference
	 *     AbstractParameter returns Reference
	 *     AbstractOperationTrait returns Reference
	 *     AbstractMessageTrait returns Reference
	 *     Reference returns Reference
	 *
	 * Constraint:
	 *     uri=AnyString
	 */
	protected void sequence_Reference(ISerializationContext context, Reference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, AsyncApiPackage.Literals.REFERENCE__URI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, AsyncApiPackage.Literals.REFERENCE__URI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReferenceAccess().getUriAnyStringParserRuleCall_4_0(), semanticObject.getUri());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractSchema returns Schema
	 *     Schema returns Schema
	 *
	 * Constraint:
	 *     (
	 *         (
	 *             title=AnyString | 
	 *             type=AnyString | 
	 *             description=AnyString | 
	 *             format=AnyString | 
	 *             minimum=INT | 
	 *             maximum=INT | 
	 *             default=PrimitiveValue | 
	 *             items=AbstractSchema
	 *         )? 
	 *         (required+=AnyString required+=AnyString*)? 
	 *         (properties+=NamedSchema properties+=NamedSchema*)? 
	 *         (enum+=PrimitiveValue enum+=PrimitiveValue*)?
	 *     )+
	 */
	protected void sequence_Schema(ISerializationContext context, Schema semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Server returns Server
	 *
	 * Constraint:
	 *     (name=AnyString ((url=AnyString | protocol=Protocol | description=AnyString)? (variables+=Variable variables+=Variable*)?)+)
	 */
	protected void sequence_Server(ISerializationContext context, Server semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tag returns Tag
	 *
	 * Constraint:
	 *     (name=AnyString | description=AnyString)*
	 */
	protected void sequence_Tag(ISerializationContext context, Tag semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=AnyString ((description=AnyString | default=AnyString)? (enum+=AnyString enum+=AnyString*)?)+)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
